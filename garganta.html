<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Effet Garganta Vanilla JS</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050508; /* Fond très sombre */
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        /* Le conteneur principal qui centre tout */
        #stage {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* La couche qui contient le vide noir et la forme */
        #garganta-void {
            position: absolute;
            /* On commence petit au centre */
            width: 10px; 
            height: 2px;
            background-color: #000000;
            
            /* C'est ici que la magie opère. 
               On utilise des drop-shadow multiples pour créer 
               le halo d'énergie intense (Bleu électrique, Cyan, Violet) */
            filter: 
                drop-shadow(0 0 5px rgba(0, 100, 255, 0.8))
                drop-shadow(0 0 15px rgba(0, 255, 255, 0.6))
                drop-shadow(0 0 30px rgba(138, 43, 226, 0.4));
            
            /* L'astuce : clip-path va découper la div carrée 
               selon une forme que l'on va définir en JS */
            /* clip-path: polygon(....); sera injecté par JS */
             will-change: clip-path, width, height;
        }

        /* Petites particules d'énergie (optionnel pour le style) */
        .particle {
            position: absolute;
            background: cyan;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
        }
    </style>
</head>
<body>

<div id="stage">
    <div id="garganta-void"></div>
</div>

<script>
    const voidElement = document.getElementById('garganta-void');
    const stage = document.getElementById('stage');

    // Configuration de l'animation
    let state = {
        opening: true,
        currentWidth: 0,
        currentHeight: 0,
        maxWidth: window.innerWidth * 1.2, // Un peu plus large que l'écran
        maxHeight: window.innerHeight * 0.3, // Hauteur écrasée (ovale)
        openingSpeed: 0.02, // Vitesse de progression (0 à 1)
        progress: 0, // Progression actuelle de l'ouverture
        noiseIntensity: 15 // Intensité de l'effet dentelé
    };

    // Fonction utilitaire pour le hasard
    const random = (min, max) => Math.random() * (max - min) + min;

    // Fonction pour générer le polygone dentelé
    // C'est le cœur de l'effet visuel.
    function generateJaggedPolygon(width, height, noiseLevel) {
        const points = [];
        // Nombre de points définissant le contour. Plus il y en a, plus c'est détaillé.
        const numPoints = 80; 
        const centerX = width / 2;
        const centerY = height / 2;

        for (let i = 0; i < numPoints; i++) {
            // On fait le tour du cercle trigonométrique
            const angle = (i / numPoints) * (Math.PI * 2);
            
            // On calcule la position de base sur une ellipse parfaite
            // Math.cos donne la position horizontale, Math.sin la verticale
            const baseX = Math.cos(angle) * (width / 2);
            const baseY = Math.sin(angle) * (height / 2);

            // AJOUT DU "BRUIT" (L'effet déchirure)
            // On ajoute une valeur aléatoire à la position du point pour le décaler
            // On réduit le bruit sur les pointes gauche/droite pour qu'elles restent pointues
            const horizontalFactor = Math.abs(Math.sin(angle)); // 0 aux pôles horizontaux, 1 aux verticaux
            
            const noiseX = random(-noiseLevel, noiseLevel) * horizontalFactor;
            const noiseY = random(-noiseLevel, noiseLevel);

            // Coordonnées finales du point, en pourcentage pour le clip-path CSS
            const xPct = ((centerX + baseX + noiseX) / width) * 100;
            const yPct = ((centerY + baseY + noiseY) / height) * 100;

            points.push(`${xPct.toFixed(2)}% ${yPct.toFixed(2)}%`);
        }

        // Retourne la chaîne CSS complète : polygon(x1 y1, x2 y2, ...)
        return `polygon(${points.join(',')})`;
    }


    // Boucle d'animation principale
    function animate() {
        // 1. Gestion de l'ouverture
        if (state.opening) {
            // Progression exponentielle pour un effet d'accélération violent
            state.progress += (1 - state.progress) * state.openingSpeed;
            
            state.currentWidth = state.maxWidth * state.progress;
            // La hauteur s'ouvre moins vite et reste écrasée
            state.currentHeight = state.maxHeight * Math.pow(state.progress, 2);

            // Si c'est presque ouvert, on arrête de l'agrandir mais on continue le tremblement
            if (state.progress > 0.99) {
                state.opening = false; 
                state.progress = 1;
            }
        }

        // 2. Application des dimensions
        // On garde une taille minimale de 10px pour éviter les bugs graphiques au départ
        const displayWidth = Math.max(10, state.currentWidth);
        const displayHeight = Math.max(4, state.currentHeight);
        
        voidElement.style.width = `${displayWidth}px`;
        voidElement.style.height = `${displayHeight}px`;

        // 3. Génération de la forme dentelée (chaque frame !)
        // Le niveau de bruit augmente légèrement avec l'ouverture pour plus de chaos
        const currentNoise = state.noiseIntensity * (0.5 + state.progress / 2);
        const polygonPath = generateJaggedPolygon(displayWidth, displayHeight, currentNoise);
        voidElement.style.clipPath = polygonPath;

        // 4. Ajout de tremblement global (Shake) sur le conteneur
        // Pour simuler l'instabilité de la réalité
        const shakeX = random(-2, 2) * state.progress;
        const shakeY = random(-1, 1) * state.progress;
        voidElement.style.transform = `translate(${shakeX}px, ${shakeY}px)`;
        

        // 5. Bonus : Génération de particules (Reiatsu)
        if (state.progress > 0.1 && Math.random() > 0.8) {
            spawnParticle();
        }

        requestAnimationFrame(animate);
    }

    // Fonction bonus pour les particules
    function spawnParticle() {
        const p = document.createElement('div');
        p.classList.add('particle');
        stage.appendChild(p);

        // Taille aléatoire
        const size = random(2, 5);
        p.style.width = `${size}px`;
        p.style.height = `${size}px`;
        
        // Position de départ : aléatoire le long de la largeur actuelle du garganta
        const startX = (window.innerWidth/2) + random(-state.currentWidth/2.2, state.currentWidth/2.2);
        p.style.left = `${startX}px`;
        p.style.top = `${window.innerHeight/2}px`;
        
        // Animation de la particule
        const destinationX = startX + random(-100, 100);
        const destinationY = (window.innerHeight/2) + random(-100, 100);

        const duration = random(500, 1000);

        p.animate([
            { transform: 'translate(0,0) scale(1)', opacity: 1, backgroundColor: '#fff' },
            { transform: `translate(${destinationX - startX}px, ${destinationY - window.innerHeight/2}px) scale(0)`, opacity: 0, backgroundColor: '#00ffff' }
        ], {
            duration: duration,
            easing: 'ease-out'
        }).onfinish = () => p.remove();
    }


    // Lancement de l'animation après un court délai
    setTimeout(() => {
        animate();
    }, 500);

    // Gestion du redimensionnement de la fenêtre
    window.addEventListener('resize', () => {
        state.maxWidth = window.innerWidth * 1.2;
        state.maxHeight = window.innerHeight * 0.3;
    });

</script>
</body>
</html>
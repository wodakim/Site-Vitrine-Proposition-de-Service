<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Garganta Bleach - Ultimate Version</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #020205, #0a0a12); /* Ciel Hueco Mundo sombre */
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #scene {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Le conteneur du vide - C'est lui qui brille */
        .garganta-wrapper {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            /* C'est ici qu'on fait l'effet NEON FLOU sur le contour précis */
            filter: 
                drop-shadow(0 0 2px rgba(0, 255, 255, 0.8)) 
                drop-shadow(0 0 8px rgba(0, 150, 255, 0.5)) 
                drop-shadow(0 0 20px rgba(0, 50, 200, 0.3));
            z-index: 10;
        }

        /* Le vide noir lui-même */
        #void {
            background-color: #000;
            width: 80vw; /* Largeur max */
            height: 60vh; /* Hauteur max */
            /* On cache l'élément tant que le JS n'a pas dessiné la forme */
            clip-path: polygon(0 50%, 100% 50%, 100% 50%, 0 50%);
            transition: transform 0.1s;
        }

        /* Les particules de Reiatsu */
        .particle {
            position: absolute;
            background: rgba(0, 255, 255, 0.8);
            pointer-events: none;
            box-shadow: 0 0 4px cyan;
            z-index: 5; /* Derrière le vide pour sortir de dedans */
        }

    </style>
</head>
<body>

<div id="scene">
    <div class="garganta-wrapper">
        <div id="void"></div>
    </div>
</div>

<script>
    const voidEl = document.getElementById('void');
    const scene = document.getElementById('scene');

    // --- CONFIGURATION ---
    const config = {
        openingSpeed: 0.008, // Vitesse d'ouverture lente et dramatique
        maxWidth: window.innerWidth * 0.9,
        maxHeight: window.innerHeight * 0.5,
        spikiness: 15, // Taille des dents/pics
        density: 120, // Nombre de points (résolution de la déchirure)
        shakeIntensity: 2 // Tremblement de la réalité
    };

    let state = {
        openRatio: 0, // 0 = fermé (ligne), 1 = ouvert
        isOpening: true,
        time: 0
    };

    // Fonction pour générer des pics aléatoires cohérents (Dents)
    function getSpike(i, total, seed) {
        // On crée une onde rapide pour faire des dents
        // Math.sin(i * fréquence) crée des vagues régulières
        // On mélange avec Math.random() pour casser la régularité
        const baseFrequency = 0.5; 
        const jagged = Math.sin(i * baseFrequency + seed) * Math.cos(i * 0.8);
        
        // Les dents sont plus petites sur les bords gauche/droite (i proche de 0 ou total)
        const edgeFactor = Math.sin((i / total) * Math.PI); 
        
        // On retourne une valeur qui va décaler Y
        return jagged * config.spikiness * edgeFactor;
    }

    function updateShape() {
        const points = [];
        const width = config.maxWidth;
        // La hauteur actuelle dépend de l'ouverture
        // On utilise easeOutOuput pour que ça s'ouvre vite puis ralentisse
        const currentHeight = config.maxHeight * Math.pow(state.openRatio, 0.8);

        // --- GÉNÉRATION DU POLYGONE ---
        
        // 1. LIGNE DU HAUT (De gauche à droite)
        for (let i = 0; i <= config.density; i++) {
            const x = (i / config.density) * 100; // X en pourcentage
            
            // Courbe de base (l'ovale du haut)
            // L'arche commence plate (0) et se courbe quand openRatio augmente
            const archY = Math.sin((i / config.density) * Math.PI) * (currentHeight / 2) * state.openRatio;
            
            // Ajout des dents (Le bruit)
            // Plus c'est ouvert, moins ça tremble, mais les dents restent
            const spike = getSpike(i, config.density, state.time);
            
            // Centre Y (50%) - Arche - Dents
            const y = 50 - (archY / (window.innerHeight*0.6) * 100) + (spike/5);
            
            points.push(`${x}% ${y}%`);
        }

        // 2. LIGNE DU BAS (De droite à gauche)
        for (let i = config.density; i >= 0; i--) {
            const x = (i / config.density) * 100;
            
            // Courbe de base inversée
            const archY = Math.sin((i / config.density) * Math.PI) * (currentHeight / 2) * state.openRatio;
            
            // Dents inversées (pour qu'elles s'imbriquent un peu au début)
            const spike = getSpike(i, config.density, state.time + 10); // +10 pour décaler le bruit
            
            // Centre Y (50%) + Arche + Dents
            const y = 50 + (archY / (window.innerHeight*0.6) * 100) + (spike/5);
            
            points.push(`${x}% ${y}%`);
        }

        // Appliquer le clip-path
        voidEl.style.clipPath = `polygon(${points.join(',')})`;
        
        // Appliquer la largeur dynamique
        voidEl.style.width = `${config.maxWidth * (0.1 + 0.9 * Math.sqrt(state.openRatio))}px`;
    }

    // --- SYSTÈME DE PARTICULES (REIATSU) ---
    function spawnParticle() {
        // On ne génère des particules que si c'est un peu ouvert
        if (state.openRatio < 0.1) return;

        const p = document.createElement('div');
        p.classList.add('particle');
        scene.appendChild(p);

        // Position aléatoire DANS le vide (approximatif)
        const spreadX = config.maxWidth * 0.8;
        const startX = (Math.random() - 0.5) * spreadX;
        const startY = (Math.random() - 0.5) * (config.maxHeight * state.openRatio * 0.5);

        // Style aléatoire (carrés verts/cyans comme dans Bleach)
        const size = Math.random() * 4 + 1;
        p.style.width = `${size}px`;
        p.style.height = `${size}px`;
        p.style.transform = `translate(${startX}px, ${startY}px)`;
        p.style.opacity = '0';

        // Animation de fuite
        // Le Reiatsu sort vers l'extérieur
        const angle = Math.atan2(startY, startX);
        const velocity = Math.random() * 100 + 50;
        const moveX = Math.cos(angle) * velocity;
        const moveY = Math.sin(angle) * velocity;

        // Animation JS Web Animation API
        const anim = p.animate([
            { transform: `translate(${startX}px, ${startY}px) rotate(0deg)`, opacity: 0 },
            { transform: `translate(${startX}px, ${startY}px) rotate(45deg)`, opacity: 1, offset: 0.2 },
            { transform: `translate(${startX + moveX}px, ${startY + moveY - 50}px) rotate(90deg)`, opacity: 0 }
        ], {
            duration: Math.random() * 1000 + 800,
            easing: 'ease-out'
        });

        anim.onfinish = () => p.remove();
    }

    // --- BOUCLE D'ANIMATION ---
    function loop() {
        state.time += 0.1;

        // 1. Gérer l'ouverture
        if (state.isOpening) {
            state.openRatio += config.openingSpeed;
            if (state.openRatio >= 1) {
                state.openRatio = 1;
                state.isOpening = false;
            }
        }

        // 2. Mettre à jour la forme
        updateShape();

        // 3. Tremblement de l'écran (Effet de puissance)
        if (state.openRatio < 1) {
            const shake = (1 - state.openRatio) * config.shakeIntensity;
            const sx = (Math.random() - 0.5) * shake;
            const sy = (Math.random() - 0.5) * shake;
            voidEl.style.transform = `translate(${sx}px, ${sy}px)`;
        } else {
            voidEl.style.transform = `translate(0,0)`;
        }

        // 4. Générer du Reiatsu
        // Plus c'est ouvert, plus il y a de particules
        if (Math.random() < state.openRatio) {
             spawnParticle();
             spawnParticle();
        }

        requestAnimationFrame(loop);
    }

    // Démarrage
    setTimeout(loop, 500);

</script>
</body>
</html>